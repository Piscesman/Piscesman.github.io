<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[java线程池初探]]></title>
      <url>%2F2017%2F04%2F09%2Fjava-thread-pool%2F</url>
      <content type="text"><![CDATA[newFixedThreadPool简述将创建一个固定长度的线程池，每当提交一个任务就创建一个线程。直到达到线程池的最大数量。这时线程池的规模不在变化（如果有个线程由于发生了未逾期的Exception而结束，那么线程池会补充一个新的线程） 代码demo123456789101112131415161718192021import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class NewFixedThreadPoolDemo &#123; //创建一个长度为2的线程池 private final ExecutorService service=Executors.newFixedThreadPool(2); public void exectorExec()&#123; for(int i = 0;i&lt;10;i++)&#123; TestRunnable text=new TestRunnable(); service.execute(text); &#125; service.shutdown(); &#125; public static void main(String[] args) &#123; NewFixedThreadPoolDemo demo=new NewFixedThreadPoolDemo(); demo.exectorExec(); &#125; &#125; 执行结果1234567891011121314151617181920pool-1-thread-2线程开始执行Tue Apr 11 23:55:59 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:55:59 CST 2017pool-1-thread-2线程执行结束Tue Apr 11 23:56:00 CST 2017pool-1-thread-2线程开始执行Tue Apr 11 23:56:00 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:56:00 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:56:00 CST 2017pool-1-thread-2线程执行结束Tue Apr 11 23:56:01 CST 2017pool-1-thread-2线程开始执行Tue Apr 11 23:56:01 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:56:01 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:56:01 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:56:02 CST 2017pool-1-thread-2线程执行结束Tue Apr 11 23:56:02 CST 2017pool-1-thread-2线程开始执行Tue Apr 11 23:56:02 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:56:02 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:56:03 CST 2017pool-1-thread-2线程执行结束Tue Apr 11 23:56:03 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:56:03 CST 2017pool-1-thread-2线程开始执行Tue Apr 11 23:56:03 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:56:04 CST 2017pool-1-thread-2线程执行结束Tue Apr 11 23:56:04 CST 2017 newCachedThreadPool简述将创建一个可缓存的线程池如果当前线程池超过了处理需求时，那么将回收空闲的线程，而当需求增加时，可以添加新的线程，线程池的规模不受限制 代码demo1234567891011121314151617181920import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class NewCachedThreadPoolDemo &#123; private final ExecutorService service=Executors.newCachedThreadPool(); public void exectorExec()&#123; for(int i=0;i&lt;10;i++)&#123; TestRunnable text=new TestRunnable(); text.setI(i); service.execute(text); &#125; service.shutdown(); &#125; public static void main(String[] args) &#123; NewCachedThreadPoolDemo demo=new NewCachedThreadPoolDemo(); demo.exectorExec(); &#125;&#125; 执行结果1234567891011121314151617181920pool-1-thread-10线程开始执行Tue Apr 11 23:54:35 CST 2017pool-1-thread-8线程开始执行Tue Apr 11 23:54:35 CST 2017pool-1-thread-4线程开始执行Tue Apr 11 23:54:35 CST 2017pool-1-thread-6线程开始执行Tue Apr 11 23:54:35 CST 2017pool-1-thread-5线程开始执行Tue Apr 11 23:54:35 CST 2017pool-1-thread-3线程开始执行Tue Apr 11 23:54:35 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:54:35 CST 2017pool-1-thread-7线程开始执行Tue Apr 11 23:54:35 CST 2017pool-1-thread-9线程开始执行Tue Apr 11 23:54:35 CST 2017pool-1-thread-2线程开始执行Tue Apr 11 23:54:35 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:54:35 CST 2017pool-1-thread-2线程执行结束Tue Apr 11 23:54:36 CST 2017pool-1-thread-3线程执行结束Tue Apr 11 23:54:37 CST 2017pool-1-thread-4线程执行结束Tue Apr 11 23:54:38 CST 2017pool-1-thread-5线程执行结束Tue Apr 11 23:54:39 CST 2017pool-1-thread-6线程执行结束Tue Apr 11 23:54:40 CST 2017pool-1-thread-7线程执行结束Tue Apr 11 23:54:41 CST 2017pool-1-thread-8线程执行结束Tue Apr 11 23:54:42 CST 2017pool-1-thread-9线程执行结束Tue Apr 11 23:54:43 CST 2017pool-1-thread-10线程执行结束Tue Apr 11 23:54:44 CST 2017 newSingleThreadPool简述单线程的Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代它。newSingleThreadExecutor能确保依照任务在队列的顺序来串行执行（例如FIFO/LIFO/优先级） 代码demo12345678910111213141516171819import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class NewSingleThreadPoolDemo &#123; private final ExecutorService service=Executors.newSingleThreadExecutor(); public void exectorExec()&#123; for(int i=0;i&lt;10;i++)&#123; TestRunnable text=new TestRunnable(); text.setI(i); service.execute(text); &#125; service.shutdown(); &#125; public static void main(String[] args) &#123; NewSingleThreadPoolDemo demo=new NewSingleThreadPoolDemo(); demo.exectorExec(); &#125;&#125; 执行结果12345678910111213141516171819pool-1-thread-1线程开始执行Tue Apr 11 23:57:18 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:57:18 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:57:18 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:57:19 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:57:19 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:57:21 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:57:21 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:57:24 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:57:24 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:57:28 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:57:28 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:57:33 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:57:33 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:57:39 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:57:39 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:57:46 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:57:46 CST 2017pool-1-thread-1线程执行结束Tue Apr 11 23:57:54 CST 2017pool-1-thread-1线程开始执行Tue Apr 11 23:57:54 CST 2017 newSecheduledThreadPool简述创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer 代码demo12345678910111213141516171819202122232425262728293031323334import java.util.Date;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.ScheduledFuture;import java.util.concurrent.TimeUnit;public class NewSecheduledThreadPoolDemo &#123; //创建任务执行器 private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); public void execHour() &#123; //声明要定时执行的任务 final Runnable exec = new Runnable() &#123; public void run() &#123; System.out.println(Thread.currentThread().getName()+"线程开始执行" + new Date(System.currentTimeMillis())); &#125; &#125;; //开启周期执行任务的计划 final ScheduledFuture&lt;?&gt; execHandle = scheduler.scheduleAtFixedRate(exec, 10, 10, TimeUnit.SECONDS); //开启一个线程用于一小时后取消这个任务 scheduler.schedule(new Runnable() &#123; @Override public void run() &#123; execHandle.cancel(true); &#125; &#125;, 60 * 60, TimeUnit.SECONDS); &#125; public static void main(String[] args) &#123; NewSecheduledThreadPoolDemo demo = new NewSecheduledThreadPoolDemo(); demo.execHour(); &#125;&#125; 执行结果1234567pool-1-thread-1线程开始执行Wed Apr 12 00:01:32 CST 2017pool-1-thread-1线程开始执行Wed Apr 12 00:01:42 CST 2017pool-1-thread-1线程开始执行Wed Apr 12 00:01:52 CST 2017pool-1-thread-1线程开始执行Wed Apr 12 00:02:02 CST 2017pool-1-thread-1线程开始执行Wed Apr 12 00:02:12 CST 2017pool-1-thread-1线程开始执行Wed Apr 12 00:02:22 CST 2017pool-1-thread-1线程开始执行Wed Apr 12 00:02:32 CST 2017]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo常见问题]]></title>
      <url>%2F2017%2F04%2F03%2FHexoProblem%2F</url>
      <content type="text"><![CDATA[一、写文章出现横向滚动条的问题 写文章时，每行写的文字比较长，出现了横线滚动条 目前的解决办法，在文章开头添加’&lt;\blockquote class=”blockquote-center”&gt;’标签。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[杭州人才引进户口迁移的详细过程]]></title>
      <url>%2F2017%2F04%2F03%2FStartHangzhou%2F</url>
      <content type="text"><![CDATA[来杭州快三年了，年初回家仔细思考了一下，觉得未来还是留在杭州比较好，决定把户口迁移到杭州。迁移的是杭州的高新区的集体户口，走的是人才引进，下面介绍一下详细的流程。 一、档案迁入 杭州市人才市场的集体户办理必须要求档案在它那里才能办理集体户 1、单位开具调档申请 2、持身份证、《调档申请》以及劳动合同到人才市场，拿到《调档函》（去办理时是在中午，只看了调档申请，就把《调档函》给我了） 3、将身份证复印件以及调档函邮寄到档案所在地（淘宝找人帮我代办的，办一次240，至少比请假回南昌要好很多） 4、代办人拿着材料去以前的档案所在地，拿到档案，注意一定要确认报道证是不是在档案里面，要不还要进行报到证补办手续 5、档案可以走机要通道，我嫌慢要求代办人帮我直接寄过来了（寄过来的档案各位千万别打开，要不然死档了） 6、拿着身份证、档案到人才市场办理档案托管手续。 二、户口 档案在网上能够查到之后 1、去杭州滨江区派出所户籍科拿到《进杭落户申请表》。（吐槽一下，户籍科和派出所居然不在一起的，太恶心了) 2、填写进杭落户申请表的相关信息，然后把申请表拿给公司人事盖章（盖章之后一定要人事签字，要签字，要签字重要的事情说三遍） 3、拿着盖了公司章的审批表、身份证及复印件，劳动合同及复印件、社保证明、《无房证明》（注意不是不动产那个，而且开两张户籍科那边审批还要用）到人才市场办理《同意落户证明》 4、持一大堆材料到杭州市公安局户籍科办理落户手续，户籍中心留下复印件，拿到回执单 5、看到杭州公安微信号上面你的审批通过以后拿着身份证和回执单到户籍科拿到进杭落户审批表红联和《准予迁入证明》 6、将身份证和户口本和准予迁入证明邮寄到户口所在地 7、将身份证、《准予迁入证明》第三联合户口迁移证邮寄回来 8、持身份证、进杭落户审批表红联、准予迁入证明第三联和《户口迁移证》到人才市场拿到同意落户证明和进杭落户告知书 9、持身份证、进杭落户审批表红联、准予迁入证明第三联、户口迁移证和同意落户证明到人才市场集体户所在派出所办理户口迁入，有需要可以同时办理新身份证 三、注意点： 1、无房证明直接开两张，人才市场和户籍科都要 2、无房证明不是不动产证明，注意不要打印错了 3、给户籍科一大堆材料主要包括：身份证及复印件，户口本以及（首页及本人页的复印件）、毕业证及复印件、学位证及复印件、劳动合同及复印件、社保证明、无房证明、进杭落户审批表 附图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hello]]></title>
      <url>%2F2017%2F03%2F18%2Fhello%2F</url>
      <content type="text"><![CDATA[你好，这是我的第一篇文章]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F18%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
